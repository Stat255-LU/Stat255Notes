[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "STAT 255 Notes",
    "section": "",
    "text": "Preface\nThese notes serve as the primary textual resource for Stat 255: Statistics for Data Science at Lawrence University.\nWhat is this course about?\nStat 255 provides an introduction to essential statistical tasks including modeling, inference, prediction, and computation. The course employs a modern approach, intended to equip students with skills needed for working with today’s complex data. Traditional concepts, like interval estimation and hypothesis testing, are introduced through the lens of multivariate models and simulation. Data computation in R plays a central role throughout the course.\nThe course’s overarching learning outcomes are:\n\nVisualize and wrangle data using statistical software R.\n\nBuild and assess multivariate models to predict future outcomes.\n\nUse statistics from samples to draw inferences about larger populations or processes.\n\nQuantify uncertainty associated with estimates and predictions.\n\nExplain the assumptions associated with statistical models, and evaluate whether these assumptions are reasonably satisfied in context.\n\nWrite reproducible analyses, using statistical software.\n\nMake ethical decisions based on data.\n\nMore specific learning tasks, related to these outcomes are provided in each chapter.\nWho is this course intended for?\nThis course is intended for students who are interested in learning statistical modeling and data computation skills that might prove useful in further courses, research, or career.\nStat 255 can serve as either:\n\na first course in statistics for students with a strong quantitative background, typically including calculus.\na second course in statistics, building on introductory topics taught in courses like Lawrence’s Stat 107: Principles of Statistics or AP Statistics.\n\nAt Lawrence, this course is required for the statistics track of the mathematics major, the economics and mathematics-economics majors, the business analytics track of the business and entrepreneurship major, and the statistics and data science minor. It also satisfies the statistics requirement for several other majors and minors.\nThe prerequisite for the course is either 1) a prior college-level course in statistics (i.e. STAT 107, BIOL 170 or 280, ANTH 207, AP Stats) OR 2) Calculus. (Math 140, AP Calculus, or equivalent).\nThe course does not assume any prior knowledge of statistics, but does move more rapidly than a typical introductory statistics course. Students engage rigorously in statistical thinking and computation, intended to equip them with essential skills for further study in statistics and data science.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "Ch1.html",
    "href": "Ch1.html",
    "title": "1  Visualizing and Summarizing Data",
    "section": "",
    "text": "1.1 Getting Started in R\nWe’ll work with data on houses that sold in King County, WA, (home of Seattle) between 2014 and 2015.\nWe begin by loading the tidyverse package which can be used to create professional data graphics and summaries.\nlibrary(tidyverse)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Visualizing and Summarizing Data</span>"
    ]
  },
  {
    "objectID": "Ch1.html#getting-started-in-r",
    "href": "Ch1.html#getting-started-in-r",
    "title": "1  Visualizing and Summarizing Data",
    "section": "",
    "text": "1.1.1 Previewing the Data\nhead()\nThe head() function displays the first 5 rows of the dataset.\n\nhead(Houses)\n\n# A tibble: 6 × 9\n     Id price bedrooms bathrooms sqft_living sqft_lot condition waterfront\n  &lt;int&gt; &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;    &lt;dbl&gt; &lt;fct&gt;     &lt;fct&gt;     \n1     1 1225         4      4.5         5420   101930 average   No        \n2     2  885.        4      2.5         2830     5000 average   No        \n3     3  385.        4      1.75        1620     4980 good      No        \n4     4  253.        2      1.5         1070     9643 average   No        \n5     5  468.        2      1           1160     6000 good      No        \n6     6  310.        3      1           1430    19901 good      No        \n# ℹ 1 more variable: yr_built &lt;dbl&gt;\n\n\nThe rows of the dataset are called observations. In this case, the observations are the houses.\nThe columns of the dataset, which contain information about the houses, are called variables.\nglimpse\nThe glimpse() command shows the number of observations (rows), and the number of variables, (columns). We also see the name of each variable and its type. Variable types include\n\nCategorical variables, which take on groups or categories, rather than numeric values. In R, these might be coded as logical &lt;logi&gt;, character &lt;chr&gt;, factor &lt;fct&gt; and ordered factor &lt;ord&gt;.\nQuantitative variables, which take on meaningful numeric values. These include numeric &lt;num&gt;, integer &lt;int&gt;, and double &lt;dbl&gt;.\nDate and time variables take on values that are dates and times, and are denoted &lt;dttm&gt;\n\n\nglimpse(Houses)\n\nRows: 100\nColumns: 9\n$ Id          &lt;int&gt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17,…\n$ price       &lt;dbl&gt; 1225.00, 885.00, 385.00, 252.70, 468.00, 310.00, 550.00, 4…\n$ bedrooms    &lt;dbl&gt; 4, 4, 4, 2, 2, 3, 4, 4, 3, 3, 3, 4, 5, 3, 4, 4, 3, 4, 3, 3…\n$ bathrooms   &lt;dbl&gt; 4.50, 2.50, 1.75, 1.50, 1.00, 1.00, 1.00, 1.00, 1.00, 2.25…\n$ sqft_living &lt;dbl&gt; 5420, 2830, 1620, 1070, 1160, 1430, 1660, 1600, 960, 1660,…\n$ sqft_lot    &lt;dbl&gt; 101930, 5000, 4980, 9643, 6000, 19901, 34848, 4300, 6634, …\n$ condition   &lt;fct&gt; average, average, good, average, good, good, poor, good, a…\n$ waterfront  &lt;fct&gt; No, No, No, No, No, No, No, No, No, No, No, No, No, No, No…\n$ yr_built    &lt;dbl&gt; 2001, 1995, 1947, 1985, 1942, 1927, 1933, 1916, 1952, 1979…\n\n\nThere are 100 houses in the dataset, and 9 variables on each house.\nsummary\nsummary displays the mean, minimum, first quartile, median, third quartile, and maximum for each numeric variable, and the number of observations in each category, for categorical variables.\n\nsummary(Houses)\n\n       Id             price           bedrooms      bathrooms    \n Min.   :  1.00   Min.   : 180.0   Min.   :1.00   Min.   :0.750  \n 1st Qu.: 25.75   1st Qu.: 322.9   1st Qu.:3.00   1st Qu.:1.500  \n Median : 50.50   Median : 507.5   Median :3.00   Median :2.000  \n Mean   : 50.50   Mean   : 735.4   Mean   :3.39   Mean   :2.107  \n 3rd Qu.: 75.25   3rd Qu.: 733.8   3rd Qu.:4.00   3rd Qu.:2.500  \n Max.   :100.00   Max.   :5300.0   Max.   :6.00   Max.   :6.000  \n  sqft_living      sqft_lot          condition  waterfront    yr_built   \n Min.   : 440   Min.   :  1044   poor     : 1   No :85     Min.   :1900  \n 1st Qu.:1410   1st Qu.:  5090   fair     : 1   Yes:15     1st Qu.:1948  \n Median :2000   Median :  7852   average  :59              Median :1966  \n Mean   :2291   Mean   : 13205   good     :30              Mean   :1965  \n 3rd Qu.:2735   3rd Qu.: 12246   very_good: 9              3rd Qu.:1991  \n Max.   :8010   Max.   :101930                             Max.   :2014  \n\n\n\n\n1.1.2 Modifying the Data\nNext we’ll look at how to manipulate the data and create new variables.\n\nAdding a New Variable\nWe can use the mutate() function to create a new variable based on variables already in the dataset.\nLet’s add a variable giving the age of the house, as of 2015.\n\nHouses &lt;- Houses |&gt; mutate(age = 2015-yr_built)\nhead(Houses)\n\n# A tibble: 6 × 10\n     Id price bedrooms bathrooms sqft_living sqft_lot condition waterfront\n  &lt;int&gt; &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;    &lt;dbl&gt; &lt;fct&gt;     &lt;fct&gt;     \n1     1 1225         4      4.5         5420   101930 average   No        \n2     2  885.        4      2.5         2830     5000 average   No        \n3     3  385.        4      1.75        1620     4980 good      No        \n4     4  253.        2      1.5         1070     9643 average   No        \n5     5  468.        2      1           1160     6000 good      No        \n6     6  310.        3      1           1430    19901 good      No        \n# ℹ 2 more variables: yr_built &lt;dbl&gt;, age &lt;dbl&gt;\n\n\n\n\nSelecting Columns\nIf the dataset contains a large number of variables, narrow down to the ones you are interested in working with. This can be done with the select() command. If there are not very many variables to begin with, or you are interested in all of them, then you may skip this step.\nLet’s create a smaller version of the dataset, with only the columns price, sqft_living, and waterfront. We’ll call this Houses_3var.\n\nHouses_3var &lt;- Houses |&gt; select(price, sqft_living, waterfront)\nhead(Houses_3var)\n\n# A tibble: 6 × 3\n  price sqft_living waterfront\n  &lt;dbl&gt;       &lt;dbl&gt; &lt;fct&gt;     \n1 1225         5420 No        \n2  885.        2830 No        \n3  385.        1620 No        \n4  253.        1070 No        \n5  468.        1160 No        \n6  310.        1430 No        \n\n\n\n\nFiltering by Row\nThe filter() command narrows a dataset down to rows that meet specified conditions.\nWe’ll filter the data to include only houses built after 2000.\n\nNew_Houses &lt;- Houses |&gt; filter(yr_built&gt;=2000)\nhead(New_Houses)\n\n# A tibble: 6 × 10\n     Id price bedrooms bathrooms sqft_living sqft_lot condition waterfront\n  &lt;int&gt; &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;    &lt;dbl&gt; &lt;fct&gt;     &lt;fct&gt;     \n1     1 1225         4      4.5         5420   101930 average   No        \n2    16 3075         4      5           4550    18641 average   Yes       \n3    23  862.        5      2.75        3595     5639 average   No        \n4    24  360.        4      2.5         2380     5000 average   No        \n5    25  625.        4      2.5         2570     5520 average   No        \n6    27  488.        3      2.5         3160    13603 average   No        \n# ℹ 2 more variables: yr_built &lt;dbl&gt;, age &lt;dbl&gt;\n\n\nNow, we’ll filter the data to include only houses on the waterfront.\n\nNew_Houses &lt;- Houses |&gt; filter(waterfront == \"Yes\")\nhead(New_Houses)\n\n# A tibble: 6 × 10\n     Id price bedrooms bathrooms sqft_living sqft_lot condition waterfront\n  &lt;int&gt; &lt;dbl&gt;    &lt;dbl&gt;     &lt;dbl&gt;       &lt;dbl&gt;    &lt;dbl&gt; &lt;fct&gt;     &lt;fct&gt;     \n1    16 3075         4      5           4550    18641 average   Yes       \n2    19  995.        3      4.5         4380    47044 average   Yes       \n3    34  825.        2      1           1150    12775 good      Yes       \n4    40 2400.        4      2.5         3650     8354 average   Yes       \n5    42  290.        2      0.75         440     8313 good      Yes       \n6    46 5111.        5      5.25        8010    45517 average   Yes       \n# ℹ 2 more variables: yr_built &lt;dbl&gt;, age &lt;dbl&gt;",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Visualizing and Summarizing Data</span>"
    ]
  },
  {
    "objectID": "Ch1.html#summary-statistics",
    "href": "Ch1.html#summary-statistics",
    "title": "1  Visualizing and Summarizing Data",
    "section": "1.2 Summary Statistics",
    "text": "1.2 Summary Statistics\n\n1.2.1 Measures of Center\nCommon ways to characterize the center of a distribution include mean, median, and mode.\nFor a set of \\(n\\) values \\(y_i, \\ldots, y_n\\):\n\nmean (\\(\\bar{y}\\)) represents the numerical average and is calculated by \\(\\bar{y} =\\frac{1}{n}\\displaystyle\\sum_{i=1}^n y_i\\).\nmedian represents the middle number when the values are arranged from least to greatest. If there are an even number of values in the dataset, then the median is given by the average of the middle two numbers.\n\nThe median of the upper half of the values is called the upper (or 3rd) quartile. This represents the 75th percentile in the distribution.\nThe median of the upper half of the values is called the lower (or 1st) quartile. This represents the 25th percentile in the distribution.\n\nmode is the most frequently occurring number in the data.\n\n\n\n1.2.2 Measures of Spread\nCommon ways of measuring the amount of spread, or variability, in a variable include:\n\nrange: the difference between the maximum and minimum values\ninterquartile range: the difference between the upper and lower quartiles (i.e. the range of the middle 50% of the values).\nstandard deviation (\\(s\\)): standard deviation is approximately the average deviation between an observation and the mean. It is calculated by\n\\(s =\\sqrt{\\displaystyle\\sum_{i=1}^n \\frac{(y_i-\\bar{y})^2}{n-1}}\\).\nThe square of the standard deviation, called the variance is denoted \\(s^2\\).\n\n\n\n1.2.3 Calcularing Summary Statistics in R\nLet’s calculate the mean, median, and standard deviation, in prices.\n\nHouses_Summary &lt;- Houses |&gt; summarize(Mean_Price = mean(price, na.rm=TRUE), \n                                          Median_Price = median(price, na.rm=TRUE), \n                                          StDev_Price = sd(price, na.rm = TRUE),\n                                          Number_of_Houses = n()) \nHouses_Summary\n\n# A tibble: 1 × 4\n  Mean_Price Median_Price StDev_Price Number_of_Houses\n       &lt;dbl&gt;        &lt;dbl&gt;       &lt;dbl&gt;            &lt;int&gt;\n1       735.         507.        835.              100\n\n\nNotes:\n1. The n() command calculates the number of observations.\n2. The na.rm=TRUE command removes missing values, so that summary statistics can be calculated. It’s not needed here, since this dataset doesn’t include missing values, but if the dataset does include missing values, you will need to include this, in order to do the calculation.\nThe kable() function in the knitr() package creates tables with professional appearance.\n\nlibrary(knitr)\nkable(Houses_Summary)\n\n\n\n\nMean_Price\nMedian_Price\nStDev_Price\nNumber_of_Houses\n\n\n\n\n735.3525\n507.5\n835.1231\n100\n\n\n\n\n\n\n\n1.2.4 Grouped Summaries\ngroup_by()\nThe group_by() command allows us to calculate summary statistics, with the data broken down by by category.We’ll compare waterfront houses to non-waterfront houses.\n\nHouses_Grouped_Summary &lt;- Houses |&gt; group_by(waterfront) |&gt; \n                                      summarize(Mean_Price = mean(price, na.rm=TRUE),\n                                                Median_Price = median(price, na.rm=TRUE), \n                                                StDev_Price = sd(price, na.rm = TRUE),\n                                                Number_of_Houses = n()) \nkable(Houses_Grouped_Summary)\n\n\n\n\nwaterfront\nMean_Price\nMedian_Price\nStDev_Price\nNumber_of_Houses\n\n\n\n\nNo\n523.7595\n450\n295.7991\n85\n\n\nYes\n1934.3800\n1350\n1610.7959\n15\n\n\n\n\n\nNote: arrange(desc(Mean_Gross)) arranges the table in descending order of Mean_Gross. To arrange in ascending order, use arrange(Mean_Gross).",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Visualizing and Summarizing Data</span>"
    ]
  },
  {
    "objectID": "Ch1.html#data-visualization",
    "href": "Ch1.html#data-visualization",
    "title": "1  Visualizing and Summarizing Data",
    "section": "1.3 Data Visualization",
    "text": "1.3 Data Visualization\nNext, we’ll create graphics to help us visualize the distributions and relationships between variables. We’ll use the ggplot() function, which is part of the tidyverse package.\n\n1.3.1 Histogram\nHistograms are useful for displaying the distribution of a single quantitative variable. In a histogram, the x-axis breaks the variable into ranges of values, and the y-axis displays the number of observations with a value falling in that category (frequency).\nGeneral Template for Histogram\n\nggplot(data=DatasetName, aes(x=VariableName)) + \n  geom_histogram(fill=\"colorchoice\", color=\"colorchoice\") + \n  ggtitle(\"Plot Title\") +\n  xlab(\"x-axis label\") + \n  ylab(\"y-axis label\")\n\nHistogram of House Prices\n\nggplot(data=Houses, aes(x=price)) + \n  geom_histogram(fill=\"lightblue\", color=\"white\") + \n  ggtitle(\"Distribution of House Prices\") +\n  xlab(\"Price (in thousands)\") + \n  ylab(\"Frequency\")\n\n\n\n\n\n\n\n\nWe see that the distribution of house prices is right-skewed. Most houses cost less than $1,000,000, though there are a few houses that are much more expensive. The most common price range is around $400,000 to $500,000.\n\n\n1.3.2 Density Plot\nDensity plots show the distribution for a quantitative variable price. Scores can be compared across categories, like whether or not the house is on a waterfront.\nGeneral Template for Density Plot\n\nggplot(data=DatasetName, aes(x=QuantitativeVariable,\n                             color=CategoricalVariable, fill=CategoricalVariable)) + \n  geom_density(alpha=0.2) + \n  ggtitle(\"Plot Title\") +\n  xlab(\"Axis Label\") + \n  ylab(\"Frequency\") \n\nalpha, ranging from 0 to 1 dictates transparency.\nDensity Plot of House Prices\n\nggplot(data=Houses, aes(x=price, color=waterfront, fill=waterfront)) + \n  geom_density(alpha=0.2) + \n  ggtitle(\"Distribution of Prices\") +\n  xlab(\"House price (in thousands)\") + \n  ylab(\"Frequency\") \n\n\n\n\n\n\n\n\nWe see that on average, houses on the waterfront tend to be more expensive and have a greater price range than houses not on the waterfront.\n\n\n1.3.3 Boxplot\nBoxplots can be used to compare a quantitative variable with a categorical variable. The middle 50% of observations are contained in the “box”, with the upper and lower 25% of the observations in each tail.\nGeneral Template for Boxplot\n\nggplot(data=DatasetName, aes(x=CategoricalVariable, \n                             y=QuantitativeVariable)) + \n  geom_boxplot() + \n  ggtitle(\"Plot Title\") + \n  xlab(\"Variable Name\") + ylab(\"Variable Name\") \n\nYou can make the plot horizontal by adding + coordflip(). You can turn the axis text vertical by adding theme(axis.text.x = element_text(angle = 90)).\nBoxplot Comparing Price by Waterfront Status\n\nggplot(data=Houses, aes(x=waterfront, y=price)) + geom_boxplot() + \n  ggtitle(\"House Price by Waterfront Status\") + \n  xlab(\"Waterfront\") + ylab(\"Price (in thousands)\") + coord_flip()\n\n\n\n\n\n\n\n\nFor houses not on the waterfront, the median price is about $400,000, and the middle 50% of prices range from about $300,000 to $600,000.\nFor waterfront houses, the median price is about $1,500,000, and the middle 50% of prices range from about $900,000 to $1,900,000.\n\n\n1.3.4 Violin Plot\nViolin plots are an alternative to boxplots. The width of the violin tells us the density of observations in a given range.\nGeneral Template for Violin Plot\n\nggplot(data=DatasetName, aes(x=CategoricalVariable, y=QuantitativeVariable, \n                             fill=CategoricalVariable)) + \n  geom_violin() + \n  ggtitle(\"Plot Title\") + \n  xlab(\"Variable Name\") + ylab(\"Variable Name\") \n\nViolin Plot Comparing Prices by Waterfront\n\nggplot(data=Houses, aes(x=waterfront, y=price, fill=waterfront)) + \n  geom_violin() + \n  ggtitle(\"Price by Waterfront Status\") + \n  xlab(\"Waterfront\") + ylab(\"Price (in thousands)\") + \n  theme(axis.text.x = element_text(angle = 90))\n\n\n\n\n\n\n\n\nAgain, we see that houses on the waterfront tend to be more expensive than those not on the waterfront, and have a wider range in prices.\n\n\n1.3.5 Scatterplot\nScatterplots are used to visualize the relationship between two quantitative variables.\nScatterplot Template\n\nggplot(data=DatasetName, aes(x=CategoricalVariable, y=QuantitativeVariable)) + \n  geom_point() +\n  ggtitle(\"Plot Title\") + \n  ylab(\"Axis Label\") + \n  xlab(\"Axis Label\")\n\nScatterplot Comparing Price and Square Feet of Living Space\n\nggplot(data=Houses, aes(x=sqft_living, y=price)) + \n  geom_point() +\n  ggtitle(\"Price and Living Space\") + \n  ylab(\"Price (in thousands)\") + \n  xlab(\"Living Space in sq. ft. \")\n\n\n\n\n\n\n\n\nWe see that there is an upward trend, indicating that houses with more living space tend to, on average, be higher priced than those with less living space. The relationship appears to be roughly linear, though there might be some curvature, as living space gets very large. There are some exceptions to this trend, most notably a house with more than 7,000 square feet, priced just over $1,000,000.\nWe can also add color, size, and shape to the scatterplot to display information about other variables.\nWe’ll use color to illustrate whether the house is on the waterfront, and size to represent the square footage of the entire lot (including the yard and the house).\n\nggplot(data=Houses, \n       aes(x=sqft_living, y=price, color=waterfront, size=sqft_lot)) + \n  geom_point() +\n  ggtitle(\"Price of King County Houses\") + \n  ylab(\"Price (in thousands)\") + \n  xlab(\"Living Space in sq. ft. \")\n\n\n\n\n\n\n\n\nWe notice that many of the largest and most expensive houses are on the waterfront.\n\n\n1.3.6 Bar Graph\nBar graphs can be used to visualize one or more categorical variables. A bar graph is similar to a histogram, in that the y-axis again displays frequency, but the x-axis displays categories, instead of ranges of values.\nBar Graph Template\n\nggplot(data=DatasetName, aes(x=CategoricalVariable)) + \n  geom_bar(fill=\"colorchoice\",color=\"colorchoice\")  + \n  ggtitle(\"Plot Title\") + \n  xlab(\"Variable Name\") + \n  ylab(\"Frequency\") \n\nBar Graph by Condition\n\nggplot(data=Houses, aes(x=condition)) + \n  geom_bar(fill=\"lightblue\",color=\"white\")  + \n  ggtitle(\"Number of Houses by Condition\") + \n  xlab(\"Condition\") + \n  ylab(\"Frequency\") +   \n  theme(axis.text.x = element_text(angle = 90))\n\n\n\n\n\n\n\n\nWe see that the majority of houses are in average condition. Some are in good or very good condition, while very few are in poor or very poor condition.\n\n\n1.3.7 Stacked and Side-by-Side Bar Graphs\nStacked Bar Graph Template\n\nggplot(data = DatasetName, mapping = aes(x = CategoricalVariable1, \n                                         fill = CategoricalVariable2)) +\n    stat_count(position=\"fill\")  +\n  theme_bw() + ggtitle(\"Plot Title\") + \n  xlab(\"Variable 1\") + \n  ylab(\"Proportion of Variable 2\") +   \n  theme(axis.text.x = element_text(angle = 90)) \n\nStacked Bar Graph Example\nThe stat_count(position=\"fill\") command creates a stacked bar graph, comparing two categorical variables. Let’s explore whether waterfront status is related to condition.\n\nggplot(data = Houses, mapping = aes(x = waterfront, fill = condition)) +\n    stat_count(position=\"fill\")  +\n  theme_bw() + ggtitle(\"Condition by Waterfront Status\") + \n  xlab(\"Waterfront Status\") + \n  ylab(\"Condition\") +   \n  theme(axis.text.x = element_text(angle = 90)) \n\n\n\n\n\n\n\n\nWe see that a higher proportion of waterfront houses are in good or excellent condition than non-waterfront houses.\nSide-by-side Bar Graph Template\nWe can create a side-by-side bar graph, using position=dodge.\n\nggplot(data = DatasetName, mapping = aes(x = CategoricalVariable1, \n                                         fill = CategoricalVariable2)) +\n    geom_bar(position = \"dodge\") +\n  ggtitle(\"Plot Title\") + \n  xlab(\"Genre\") + \n  ylab(\"Frequency\") \n\nSide-by-side Bar Graph Example\n\nggplot(data = Houses, mapping = aes(x = waterfront, fill = condition)) +\n    geom_bar(position = \"dodge\") +\n  ggtitle(\"Condition by Waterfront Status\") + \n  xlab(\"Waterfront Status\") + \n  ylab(\"Condition\") +   \n  theme(axis.text.x = element_text(angle = 90)) \n\n\n\n\n\n\n\n\nIn this case, since there are so few waterfront houses, the graph is hard to read and not very useful.\nThe stacked bar graph is a better way to convey information in this instance, though you may find that for a different dataset, the side-by-side bar graph could be a better choice.\n\n\n1.3.8 Correlation Plot\nCorrelation plots can be used to visualize relationships between quantitative variables. Correlation is a number between -1 and 1, describing the strength of the linear relationship between two variables. Variables with strong positive correlations will have correlation close to +1, while variables with strong negative correlations will have correlations close to -1. Variables with little to no relationship will have correlation close to 0.\nThe cor() function calculates correlations between quantitative variables. We’ll use select_if to select only numeric variables. The `use=“complete.obs” command tells R to ignore observations with missing data.\n\ncor(select_if(Houses, is.numeric), use=\"complete.obs\") |&gt; round(2)\n\n               Id price bedrooms bathrooms sqft_living sqft_lot yr_built   age\nId           1.00  0.03    -0.06     -0.01       -0.03    -0.07    -0.02  0.02\nprice        0.03  1.00     0.40      0.67        0.81     0.42     0.17 -0.17\nbedrooms    -0.06  0.40     1.00      0.58        0.58     0.15     0.26 -0.26\nbathrooms   -0.01  0.67     0.58      1.00        0.85     0.45     0.50 -0.50\nsqft_living -0.03  0.81     0.58      0.85        1.00     0.54     0.36 -0.36\nsqft_lot    -0.07  0.42     0.15      0.45        0.54     1.00     0.14 -0.14\nyr_built    -0.02  0.17     0.26      0.50        0.36     0.14     1.00 -1.00\nage          0.02 -0.17    -0.26     -0.50       -0.36    -0.14    -1.00  1.00\n\n\nThe corrplot() function in the corrplot() package provides a visualization of the correlations. Larger, thicker circles indicate stronger correlations.\n\nlibrary(corrplot)\nCorr &lt;- cor(select_if(Houses, is.numeric), use=\"complete.obs\")\ncorrplot(Corr)\n\n\n\n\n\n\n\n\nWe see that price has a strong positive correlation with square feet of living space, and is also positively correlated with number of bedrooms and bathrooms. Living space, bedrooms, and bathrooms are all positively correlated, which makes sense, since we would expect bigger houses to have more bedrooms and bathrooms. Price does not show much correlation with the other variables. We notice that bathrooms is negatively correlated with age, which means older houses tend to have fewer bathrooms than newer ones. Not surprisingly, age is very strongly correlated with year built.\n\n\n1.3.9 Scatterplot Matrix\nA scatterplot matrix is a grid of plots. It can be created using the ggpairs() function in the GGally package.\nThe scatterplot matrix shows us:\n\nAlong the diagonal are density plots for quantitative variables, or bar graphs for categorical variables, showing the distribution of each variable.\n\nUnder the diagonal are plots showing the relationships between the variables in the corresponding row and column. Scatterplots are used when both variables are quantitative, bar graphs are used when both variables are categorical, and boxplots are used when one variable is categorical, and the other is quantitative.\n\nAbove the diagonal are correlations between quantitative variables.\n\nIncluding too many variables can make these hard to read, so it’s a good idea to use select to narrow down the number of variables.\n\nlibrary(GGally)\nggpairs(Houses |&gt; select(price, sqft_living, condition, age))\n\n\n\n\n\n\n\n\nThe scatterplot matrix is useful for helping us notice key trends in our data. However, the plot can hard to read as it is quite dense, especially when there are a large number of variables. These can help us look for trends from a distance, but we should then focus in on more specific plots.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>Visualizing and Summarizing Data</span>"
    ]
  }
]